-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/model_biquad_wfa/axis_goertzel_ip_src_Subsystem.vhd
-- Created: 2021-03-26 18:29:33
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: axis_goertzel_ip_src_Subsystem
-- Source Path: model_biquad_wfa/goertzel_ip/Subsystem
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.axis_goertzel_ip_src_model_biquad_wfa_pkg.ALL;

ENTITY axis_goertzel_ip_src_Subsystem IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        input_data                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        wkn                               :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        incos                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        Enable                            :   IN    std_logic;
        output_data                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
        );
END axis_goertzel_ip_src_Subsystem;


ARCHITECTURE rtl OF axis_goertzel_ip_src_Subsystem IS

  -- Component Declarations
  COMPONENT axis_goertzel_ip_src_Biquad_Filter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Biquad_Filter_in                :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
          Biquad_Filter_num               :   IN    vector_of_std_logic_vector32(0 TO 2);  -- sfix32_En16 [3]
          Biquad_Filter_den               :   IN    vector_of_std_logic_vector32(0 TO 1);  -- sfix32_En16 [2]
          Biquad_Filter_out               :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : axis_goertzel_ip_src_Biquad_Filter
    USE ENTITY work.axis_goertzel_ip_src_Biquad_Filter(rtl);

  -- Signals
  SIGNAL Enable_out4                      : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL Counter_Free_Running_out1        : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL input_data_signed                : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL enb_gated_2                      : std_logic;
  SIGNAL Constant3_out1                   : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Constant5_out1                   : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Mux_out1                         : vector_of_signed32(0 TO 2);  -- sfix32_En16 [3]
  SIGNAL enb_gated_3                      : std_logic;
  SIGNAL Constant1_out1                   : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Mux1_out1                        : vector_of_signed32(0 TO 1);  -- sfix32_En16 [2]
  SIGNAL enb_gated_4                      : std_logic;
  SIGNAL Resettable_Delay_switch_delay    : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL Resettable_Delay_out1            : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Resettable_Delay1_switch_delay   : vector_of_signed32(0 TO 2);  -- sfix32 [3]
  SIGNAL Resettable_Delay1_out1           : vector_of_signed32(0 TO 2);  -- sfix32_En16 [3]
  SIGNAL Resettable_Delay1_out1_1         : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL Resettable_Delay2_switch_delay   : vector_of_signed32(0 TO 1);  -- sfix32 [2]
  SIGNAL Resettable_Delay2_out1           : vector_of_signed32(0 TO 1);  -- sfix32_En16 [2]
  SIGNAL Resettable_Delay2_out1_1         : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL enb_gated_5                      : std_logic;
  SIGNAL Biquad_Filter_out1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Biquad_Filter_out1_signed        : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Resettable_Delay3_switch_delay   : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL Resettable_Delay3_out1           : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Resettable_Delay3_out1_1         : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Resettable_Delay3_out1_last_value : signed(31 DOWNTO 0);  -- sfix32_En16

BEGIN
  u_Biquad_Filter : axis_goertzel_ip_src_Biquad_Filter
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb_gated_5,
              Biquad_Filter_in => std_logic_vector(Resettable_Delay_out1),  -- sfix32_En16
              Biquad_Filter_num => Resettable_Delay1_out1_1,  -- sfix32_En16 [3]
              Biquad_Filter_den => Resettable_Delay2_out1_1,  -- sfix32_En16 [2]
              Biquad_Filter_out => Biquad_Filter_out1  -- sfix32_En16
              );

  Enable_out4 <= Enable;

  enb_gated <= Enable_out4 AND enb;

  enb_gated_1 <= Enable_out4 AND enb;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  Counter_Free_Running_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Counter_Free_Running_out1 <= to_unsigned(16#00#, 6);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_1 = '1' THEN
        Counter_Free_Running_out1 <= Counter_Free_Running_out1 + to_unsigned(16#01#, 6);
      END IF;
    END IF;
  END PROCESS Counter_Free_Running_process;


  
  Compare_To_Constant_out1 <= '1' WHEN Counter_Free_Running_out1 >= to_unsigned(16#22#, 6) ELSE
      '0';

  input_data_signed <= signed(input_data);

  enb_gated_2 <= Enable_out4 AND enb;

  Constant3_out1 <= to_signed(65536, 32);

  Constant5_out1 <= to_signed(0, 32);

  Mux_out1(0) <= Constant3_out1;
  Mux_out1(1) <= signed(wkn);
  Mux_out1(2) <= Constant5_out1;

  enb_gated_3 <= Enable_out4 AND enb;

  Constant1_out1 <= to_signed(65536, 32);

  Mux1_out1(0) <= signed(incos);
  Mux1_out1(1) <= Constant1_out1;

  enb_gated_4 <= Enable_out4 AND enb;

  Resettable_Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Resettable_Delay_switch_delay <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_2 = '1' THEN
        IF Compare_To_Constant_out1 = '1' THEN
          Resettable_Delay_switch_delay <= to_signed(0, 32);
        ELSE 
          Resettable_Delay_switch_delay <= input_data_signed;
        END IF;
      END IF;
    END IF;
  END PROCESS Resettable_Delay_process;

  
  Resettable_Delay_out1 <= to_signed(0, 32) WHEN Compare_To_Constant_out1 = '1' ELSE
      Resettable_Delay_switch_delay;

  Resettable_Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Resettable_Delay1_switch_delay <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_3 = '1' THEN
        IF Compare_To_Constant_out1 = '1' THEN
          Resettable_Delay1_switch_delay <= (OTHERS => to_signed(0, 32));
        ELSE 
          Resettable_Delay1_switch_delay <= Mux_out1;
        END IF;
      END IF;
    END IF;
  END PROCESS Resettable_Delay1_process;

  
  Resettable_Delay1_out1 <= (OTHERS => to_signed(0, 32)) WHEN Compare_To_Constant_out1 = '1' ELSE
      Resettable_Delay1_switch_delay;

  outputgen1: FOR k IN 0 TO 2 GENERATE
    Resettable_Delay1_out1_1(k) <= std_logic_vector(Resettable_Delay1_out1(k));
  END GENERATE;

  Resettable_Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Resettable_Delay2_switch_delay <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated_4 = '1' THEN
        IF Compare_To_Constant_out1 = '1' THEN
          Resettable_Delay2_switch_delay <= (OTHERS => to_signed(0, 32));
        ELSE 
          Resettable_Delay2_switch_delay <= Mux1_out1;
        END IF;
      END IF;
    END IF;
  END PROCESS Resettable_Delay2_process;

  
  Resettable_Delay2_out1 <= (OTHERS => to_signed(0, 32)) WHEN Compare_To_Constant_out1 = '1' ELSE
      Resettable_Delay2_switch_delay;

  outputgen: FOR k IN 0 TO 1 GENERATE
    Resettable_Delay2_out1_1(k) <= std_logic_vector(Resettable_Delay2_out1(k));
  END GENERATE;

  enb_gated_5 <= Enable_out4 AND enb;

  Biquad_Filter_out1_signed <= signed(Biquad_Filter_out1);

  Resettable_Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Resettable_Delay3_switch_delay <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        IF Compare_To_Constant_out1 = '1' THEN
          Resettable_Delay3_switch_delay <= to_signed(0, 32);
        ELSE 
          Resettable_Delay3_switch_delay <= Biquad_Filter_out1_signed;
        END IF;
      END IF;
    END IF;
  END PROCESS Resettable_Delay3_process;

  
  Resettable_Delay3_out1 <= to_signed(0, 32) WHEN Compare_To_Constant_out1 = '1' ELSE
      Resettable_Delay3_switch_delay;

  out0_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Resettable_Delay3_out1_last_value <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        Resettable_Delay3_out1_last_value <= Resettable_Delay3_out1_1;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  Resettable_Delay3_out1_1 <= Resettable_Delay3_out1_last_value WHEN Enable_out4 = '0' ELSE
      Resettable_Delay3_out1;

  output_data <= std_logic_vector(Resettable_Delay3_out1_1);

END rtl;

