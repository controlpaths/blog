// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/model/axis_goertzel_axi_lite_module.v
// Created: 2021-03-13 19:16:38
// 
// Generated by MATLAB 9.9 and HDL Coder 3.17
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: axis_goertzel_axi_lite_module
// Source Path: axis_goertzel/axis_goertzel_axi_lite/axis_goertzel_axi_lite_module
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module axis_goertzel_axi_lite_module
          (clk,
           AXI4_Lite_ARESETN,
           AXI4_Lite_AWADDR,
           AXI4_Lite_AWVALID,
           AXI4_Lite_WDATA,
           AXI4_Lite_WSTRB,
           AXI4_Lite_WVALID,
           AXI4_Lite_BREADY,
           AXI4_Lite_ARADDR,
           AXI4_Lite_ARVALID,
           AXI4_Lite_RREADY,
           data_read,
           AXI4_Lite_AWREADY,
           AXI4_Lite_WREADY,
           AXI4_Lite_BRESP,
           AXI4_Lite_BVALID,
           AXI4_Lite_ARREADY,
           AXI4_Lite_RDATA,
           AXI4_Lite_RRESP,
           AXI4_Lite_RVALID,
           data_write,
           addr_sel,
           wr_enb,
           rd_enb,
           reset_internal);


  input   clk;
  input   AXI4_Lite_ARESETN;  // ufix1
  input   [15:0] AXI4_Lite_AWADDR;  // ufix16
  input   AXI4_Lite_AWVALID;  // ufix1
  input   [31:0] AXI4_Lite_WDATA;  // ufix32
  input   [3:0] AXI4_Lite_WSTRB;  // ufix4
  input   AXI4_Lite_WVALID;  // ufix1
  input   AXI4_Lite_BREADY;  // ufix1
  input   [15:0] AXI4_Lite_ARADDR;  // ufix16
  input   AXI4_Lite_ARVALID;  // ufix1
  input   AXI4_Lite_RREADY;  // ufix1
  input   [31:0] data_read;  // ufix32
  output  AXI4_Lite_AWREADY;  // ufix1
  output  AXI4_Lite_WREADY;  // ufix1
  output  [1:0] AXI4_Lite_BRESP;  // ufix2
  output  AXI4_Lite_BVALID;  // ufix1
  output  AXI4_Lite_ARREADY;  // ufix1
  output  [31:0] AXI4_Lite_RDATA;  // ufix32
  output  [1:0] AXI4_Lite_RRESP;  // ufix2
  output  AXI4_Lite_RVALID;  // ufix1
  output  [31:0] data_write;  // ufix32
  output  [13:0] addr_sel;  // ufix14
  output  wr_enb;  // ufix1
  output  rd_enb;  // ufix1
  output  reset_internal;  // ufix1


  wire reset;
  wire enb;
  wire const_1;  // ufix1
  reg [7:0] axi_lite_wstate;  // uint8
  reg [7:0] axi_lite_rstate;  // uint8
  reg [7:0] axi_lite_wstate_next;  // uint8
  reg [7:0] axi_lite_rstate_next;  // uint8
  reg  AXI4_Lite_AWREADY_1;  // ufix1
  reg  AXI4_Lite_WREADY_1;  // ufix1
  reg  AXI4_Lite_BVALID_1;  // ufix1
  reg  AXI4_Lite_ARREADY_1;  // ufix1
  reg  rvalid_int;  // ufix1
  reg  aw_transfer;  // ufix1
  reg  w_transfer;  // ufix1
  reg  ar_transfer;  // ufix1
  wire [1:0] const_0_2;  // ufix2
  reg [31:0] AXI4_Lite_RDATA_1;  // ufix32
  reg [31:0] wdata;  // ufix32
  reg [15:0] waddr;  // ufix16
  wire [13:0] waddr_sel;  // ufix14
  wire [13:0] raddr_sel;  // ufix14
  wire wstrb_reduce;  // ufix1
  wire w_transfer_and_wstrb;  // ufix1
  reg  wr_enb_1;  // ufix1
  wire strobe_addr;  // ufix1
  wire strobe_sel;  // ufix1
  wire const_zero;  // ufix1
  wire strobe_in;  // ufix1
  wire strobe_sw;  // ufix1
  reg  soft_reset;  // ufix1
  reg  axi_lite_out0_0;
  reg  axi_lite_out1_0;
  reg  axi_lite_awvalid;
  reg  axi_lite_wvalid;
  reg  axi_lite_arvalid;
  reg  axi_lite_arready;


  assign const_1 = 1'b1;



  assign enb = const_1;

  assign reset =  ~ AXI4_Lite_ARESETN;



  always @(posedge clk or posedge reset)
    begin : axi_lite_process
      if (reset == 1'b1) begin
        axi_lite_wstate <= 8'd0;
        axi_lite_rstate <= 8'd0;
      end
      else begin
        if (enb) begin
          axi_lite_wstate <= axi_lite_wstate_next;
          axi_lite_rstate <= axi_lite_rstate_next;
        end
      end
    end

  always @(AXI4_Lite_ARVALID, AXI4_Lite_AWVALID, AXI4_Lite_BREADY, AXI4_Lite_RREADY,
       AXI4_Lite_WVALID, axi_lite_rstate, axi_lite_wstate) begin
    axi_lite_awvalid = AXI4_Lite_AWVALID != 1'b0;
    axi_lite_wvalid = AXI4_Lite_WVALID != 1'b0;
    axi_lite_arvalid = AXI4_Lite_ARVALID != 1'b0;
    case ( axi_lite_wstate)
      8'd0 :
        begin
          axi_lite_out0_0 = axi_lite_rstate == 8'd0;
          axi_lite_out1_0 = 1'b0;
          AXI4_Lite_BVALID_1 = 1'b0;
          if (axi_lite_awvalid && (axi_lite_rstate == 8'd0)) begin
            axi_lite_wstate_next = 8'd1;
          end
          else begin
            axi_lite_wstate_next = 8'd0;
          end
        end
      8'd1 :
        begin
          axi_lite_out0_0 = 1'b0;
          axi_lite_out1_0 = 1'b1;
          AXI4_Lite_BVALID_1 = 1'b0;
          if (axi_lite_wvalid) begin
            axi_lite_wstate_next = 8'd2;
          end
          else begin
            axi_lite_wstate_next = 8'd1;
          end
        end
      8'd2 :
        begin
          axi_lite_out0_0 = 1'b0;
          axi_lite_out1_0 = 1'b0;
          AXI4_Lite_BVALID_1 = 1'b1;
          if (AXI4_Lite_BREADY != 1'b0) begin
            axi_lite_wstate_next = 8'd0;
          end
          else begin
            axi_lite_wstate_next = 8'd2;
          end
        end
      default :
        begin
          axi_lite_out0_0 = 1'b0;
          axi_lite_out1_0 = 1'b0;
          AXI4_Lite_BVALID_1 = 1'b0;
          axi_lite_wstate_next = 8'd0;
        end
    endcase
    case ( axi_lite_rstate)
      8'd0 :
        begin
          axi_lite_arready = (axi_lite_wstate == 8'd0) &&  ! axi_lite_awvalid;
          rvalid_int = 1'b0;
          if ((axi_lite_arvalid && (axi_lite_wstate == 8'd0)) && ( ! axi_lite_awvalid)) begin
            axi_lite_rstate_next = 8'd1;
          end
          else begin
            axi_lite_rstate_next = 8'd0;
          end
        end
      8'd1 :
        begin
          axi_lite_arready = 1'b0;
          rvalid_int = 1'b1;
          if (AXI4_Lite_RREADY != 1'b0) begin
            axi_lite_rstate_next = 8'd0;
          end
          else begin
            axi_lite_rstate_next = 8'd1;
          end
        end
      default :
        begin
          axi_lite_arready = 1'b0;
          rvalid_int = 1'b0;
          axi_lite_rstate_next = 8'd0;
        end
    endcase
    AXI4_Lite_AWREADY_1 = axi_lite_out0_0;
    AXI4_Lite_WREADY_1 = axi_lite_out1_0;
    AXI4_Lite_ARREADY_1 = axi_lite_arready;
    aw_transfer = axi_lite_awvalid && axi_lite_out0_0;
    w_transfer = axi_lite_wvalid && axi_lite_out1_0;
    ar_transfer = axi_lite_arvalid && axi_lite_arready;
  end



  assign const_0_2 = 2'b00;



  assign AXI4_Lite_BRESP = const_0_2;

  always @(posedge clk or posedge reset)
    begin : reg_rdata_process
      if (reset == 1'b1) begin
        AXI4_Lite_RDATA_1 <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb && ar_transfer) begin
          AXI4_Lite_RDATA_1 <= data_read;
        end
      end
    end



  assign AXI4_Lite_RRESP = const_0_2;

  assign AXI4_Lite_RVALID = rvalid_int;

  always @(posedge clk or posedge reset)
    begin : reg_wdata_process
      if (reset == 1'b1) begin
        wdata <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb && w_transfer) begin
          wdata <= AXI4_Lite_WDATA;
        end
      end
    end



  assign data_write = wdata;

  always @(posedge clk or posedge reset)
    begin : reg_waddr_process
      if (reset == 1'b1) begin
        waddr <= 16'b0000000000000000;
      end
      else begin
        if (enb && aw_transfer) begin
          waddr <= AXI4_Lite_AWADDR;
        end
      end
    end



  assign waddr_sel = waddr[15:2];



  assign raddr_sel = AXI4_Lite_ARADDR[15:2];



  assign addr_sel = (AXI4_Lite_ARVALID == 1'b0 ? waddr_sel :
              raddr_sel);



  assign wstrb_reduce = (&AXI4_Lite_WSTRB[3:0]);



  assign w_transfer_and_wstrb = w_transfer & wstrb_reduce;



  always @(posedge clk or posedge reset)
    begin : reg_wr_enb_process
      if (reset == 1'b1) begin
        wr_enb_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          wr_enb_1 <= w_transfer_and_wstrb;
        end
      end
    end



  assign rd_enb = ar_transfer;

  assign strobe_addr = waddr_sel == 14'b00000000000000;



  assign strobe_sel = strobe_addr & wr_enb_1;



  assign const_zero = 1'b0;



  assign strobe_in = wdata[0];



  assign strobe_sw = (strobe_sel == 1'b0 ? const_zero :
              strobe_in);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        soft_reset <= 1'b0;
      end
      else begin
        if (enb) begin
          soft_reset <= strobe_sw;
        end
      end
    end



  assign reset_internal = reset | soft_reset;



  assign AXI4_Lite_AWREADY = AXI4_Lite_AWREADY_1;

  assign AXI4_Lite_WREADY = AXI4_Lite_WREADY_1;

  assign AXI4_Lite_BVALID = AXI4_Lite_BVALID_1;

  assign AXI4_Lite_ARREADY = AXI4_Lite_ARREADY_1;

  assign AXI4_Lite_RDATA = AXI4_Lite_RDATA_1;

  assign wr_enb = wr_enb_1;

endmodule  // axis_goertzel_axi_lite_module

