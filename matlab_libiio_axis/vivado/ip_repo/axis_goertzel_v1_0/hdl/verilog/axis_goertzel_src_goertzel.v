// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/model/axis_goertzel_src_goertzel.v
// Created: 2021-03-13 19:16:33
// 
// Generated by MATLAB 9.9 and HDL Coder 3.17
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: axis_goertzel_src_goertzel
// Source Path: model/goertzel_system/goertzel
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module axis_goertzel_src_goertzel
          (clk,
           reset,
           enb,
           Input_rsvd,
           cos_input,
           wkn_re,
           Enable,
           Re);


  input   clk;
  input   reset;
  input   enb;
  input   signed [31:0] Input_rsvd;  // sfix32_En31
  input   signed [31:0] cos_input;  // sfix32_En28
  input   signed [31:0] wkn_re;  // sfix32_En28
  input   Enable;
  output  signed [63:0] Re;  // sfix64_En56


  reg  [0:1] delayMatch1_reg;  // ufix1 [2]
  wire [0:1] delayMatch1_reg_next;  // ufix1 [2]
  wire Enable_out5;
  wire enb_gated;
  wire enb_gated_1;
  reg signed [31:0] Delay_out1;  // sfix32_En28
  wire signed [63:0] Product_out1;  // sfix64_En56
  wire signed [63:0] Sum_out1;  // sfix64_En56
  wire signed [31:0] Data_Type_Conversion_out1;  // sfix32_En28
  reg signed [31:0] Delay1_out1;  // sfix32_En28
  wire signed [32:0] Gain1_cast;  // sfix33_En28
  wire signed [32:0] Gain1_cast_1;  // sfix33_En28
  wire signed [63:0] Gain1_out1;  // sfix64_En59
  wire signed [63:0] Sum1_add_cast;  // sfix64_En56
  wire signed [63:0] Sum1_out1;  // sfix64_En56
  wire signed [63:0] Sum_add_cast;  // sfix64_En56
  reg signed [63:0] delayMatch_reg [0:1];  // sfix64 [2]
  wire signed [63:0] delayMatch_reg_next [0:1];  // sfix64_En56 [2]
  wire signed [63:0] Sum_out1_1;  // sfix64_En56
  reg signed [31:0] wkn_re_1;  // sfix32_En28
  reg signed [31:0] Delay_out1_1;  // sfix32_En28
  wire signed [63:0] Product1_out1;  // sfix64_En56
  reg signed [63:0] Product1_out1_1;  // sfix64_En56
  wire signed [63:0] Sum2_out1;  // sfix64_En56
  wire signed [63:0] Sum2_out1_bypass;  // sfix64_En56
  reg signed [63:0] Sum2_out1_last_value;  // sfix64_En56


  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        delayMatch1_reg[0] <= 1'b0;
        delayMatch1_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          delayMatch1_reg[0] <= delayMatch1_reg_next[0];
          delayMatch1_reg[1] <= delayMatch1_reg_next[1];
        end
      end
    end

  assign Enable_out5 = delayMatch1_reg[1];
  assign delayMatch1_reg_next[0] = Enable;
  assign delayMatch1_reg_next[1] = delayMatch1_reg[0];



  assign enb_gated = Enable && enb;

  assign enb_gated_1 = Enable && enb;

  assign Product_out1 = cos_input * Delay_out1;



  assign Data_Type_Conversion_out1 = Sum_out1[59:28];



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_gated) begin
          Delay_out1 <= Data_Type_Conversion_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_gated_1) begin
          Delay1_out1 <= Delay_out1;
        end
      end
    end



  assign Gain1_cast = {Delay1_out1[31], Delay1_out1};
  assign Gain1_cast_1 =  - (Gain1_cast);
  assign Gain1_out1 = {Gain1_cast_1, 31'b0000000000000000000000000000000};



  assign Sum1_add_cast = {{3{Gain1_out1[63]}}, Gain1_out1[63:3]};
  assign Sum1_out1 = Sum1_add_cast + Product_out1;



  assign Sum_add_cast = {{7{Input_rsvd[31]}}, {Input_rsvd, 25'b0000000000000000000000000}};
  assign Sum_out1 = Sum_add_cast + Sum1_out1;



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 64'sh0000000000000000;
        delayMatch_reg[1] <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
        end
      end
    end

  assign Sum_out1_1 = delayMatch_reg[1];
  assign delayMatch_reg_next[0] = Sum_out1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];



  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        wkn_re_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          wkn_re_1 <= wkn_re;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        Delay_out1_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1_1 <= Delay_out1;
        end
      end
    end



  assign Product1_out1 = wkn_re_1 * Delay_out1_1;



  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Product1_out1_1 <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_out1_1 <= Product1_out1;
        end
      end
    end



  assign Sum2_out1 = Sum_out1_1 + Product1_out1_1;



  always @(posedge clk or posedge reset)
    begin : Re_bypass_process
      if (reset == 1'b1) begin
        Sum2_out1_last_value <= 64'sh0000000000000000;
      end
      else begin
        if (enb) begin
          Sum2_out1_last_value <= Sum2_out1_bypass;
        end
      end
    end



  assign Sum2_out1_bypass = (Enable_out5 == 1'b0 ? Sum2_out1_last_value :
              Sum2_out1);



  assign Re = Sum2_out1_bypass;

endmodule  // axis_goertzel_src_goertzel

